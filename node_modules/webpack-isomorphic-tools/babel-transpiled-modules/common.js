'use strict';

var _Object$keys = require('babel-runtime/core-js/object/keys')['default'];

var _getIterator = require('babel-runtime/core-js/get-iterator')['default'];

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default')['default'];

exports.__esModule = true;
exports.default_webpack_assets = default_webpack_assets;
exports.normalize_options = normalize_options;
exports.alias_hook = alias_hook;
exports.normalize_asset_path = normalize_asset_path;
exports.webpack_path = webpack_path;
exports.uniform_path = uniform_path;

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _requireHacker = require('require-hacker');

var _requireHacker2 = _interopRequireDefault(_requireHacker);

var _helpers = require('./helpers');

// returns a stub for webpack-assets.json if it doesn't exist yet
// (because node.js and webpack are being run in parallel in development mode)

function default_webpack_assets() {
	var webpack_assets = {
		javascript: {},
		styles: {},
		assets: {}
	};

	return webpack_assets;
}

// adds missing fields, etc

function normalize_options(options) {
	// parameters check
	for (var _iterator = _Object$keys(options), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _getIterator(_iterator);;) {
		var _ref;

		if (_isArray) {
			if (_i >= _iterator.length) break;
			_ref = _iterator[_i++];
		} else {
			_i = _iterator.next();
			if (_i.done) break;
			_ref = _i.value;
		}

		var key = _ref;

		switch (key) {
			case 'assets':
				if (!_helpers.is_object(options[key])) {
					throw new Error('"' + key + '" configuration parameter must be ' + 'an object');
				}
				break;

			case 'debug':
				if (typeof options[key] !== 'boolean') {
					throw new Error('"' + key + '" configuration parameter must be ' + 'a boolean');
				}
				break;

			case 'verbose':
				if (typeof options[key] !== 'boolean') {
					throw new Error('"' + key + '" configuration parameter must be ' + 'a boolean');
				}
				break;

			case 'webpack_assets_file_path':
			case 'webpack_stats_file_path':
				if (typeof options[key] !== 'string') {
					throw new Error('"' + key + '" configuration parameter must be ' + 'a string');
				}
				break;

			case 'alias':
				if (!_helpers.is_object(options[key])) {
					throw new Error('"' + key + '" configuration parameter must be ' + 'an object');
				}
				break;

			case 'modules_directories':
				if (!Array.isArray(options[key])) {
					throw new Error('"' + key + '" configuration parameter must be ' + 'an array');
				}
				break;

			case 'require_context':
				if (typeof options[key] !== 'boolean') {
					throw new Error('"' + key + '" configuration parameter must be ' + 'a boolean');
				}
				break;

			default:
				throw new Error('Unknown configuration parameter "' + key + '"');
		}
	}

	// if no assets specified (for whatever reason), make it an empty array
	if (!options.assets) {
		// options.assets = {}
		throw new Error('You must specify "assets" parameter in webpack-isomorphic-tools configuration');
	}

	// webpack-assets.json path, relative to the project base path
	options.webpack_assets_file_path = options.webpack_assets_file_path || 'webpack-assets.json';

	// webpack-stats.json path, relative to the project base path
	options.webpack_stats_file_path = options.webpack_stats_file_path || 'webpack-stats.json';

	// if Webpack aliases are supplied, validate them
	if (options.alias) {
		for (var _iterator2 = _Object$keys(options.alias), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _getIterator(_iterator2);;) {
			var _ref2;

			if (_isArray2) {
				if (_i2 >= _iterator2.length) break;
				_ref2 = _iterator2[_i2++];
			} else {
				_i2 = _iterator2.next();
				if (_i2.done) break;
				_ref2 = _i2.value;
			}

			var key = _ref2;

			if (typeof options.alias[key] !== 'string') {
				throw new Error('Invalid alias for "' + key + '": "' + options.alias[key] + '"');
			}
		}
	}

	// generate names (if required) for each user defined asset type, normalize extensions
	for (var _iterator3 = _Object$keys(options.assets), _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _getIterator(_iterator3);;) {
		var _ref3;

		if (_isArray3) {
			if (_i3 >= _iterator3.length) break;
			_ref3 = _iterator3[_i3++];
		} else {
			_i3 = _iterator3.next();
			if (_i3.done) break;
			_ref3 = _i3.value;
		}

		var asset_type = _ref3;

		var description = options.assets[asset_type];

		// normalize extensions
		if (description.extension) {
			// sanity check
			if (Array.isArray(description.extension)) {
				throw new Error('Use "extensions" key instead of "extension" for specifying an array of file extensions for assets of type "' + asset_type + '"');
			}

			// sanity check
			if (typeof description.extension !== 'string') {
				throw new Error('"extension" value must be a string for assets of type "' + asset_type + '"');
			}

			// normalize
			description.extensions = [description.extension];
			delete description.extension;
		}

		// sanity check
		if (!description.extensions) {
			throw new Error('You must specify file extensions for assets of type "' + asset_type + '"');
		}

		// parameters check
		for (var _iterator4 = _Object$keys(description), _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _getIterator(_iterator4);;) {
			var _ref4;

			if (_isArray4) {
				if (_i4 >= _iterator4.length) break;
				_ref4 = _iterator4[_i4++];
			} else {
				_i4 = _iterator4.next();
				if (_i4.done) break;
				_ref4 = _i4.value;
			}

			var key = _ref4;

			switch (key) {
				case 'extensions':
					break;

				case 'exclude':
				case 'include':
					if (!Array.isArray(description[key])) {
						throw new Error('"' + key + '" must be an array for asset type "' + asset_type + '"');
					}
					for (var _iterator5 = description[key], _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _getIterator(_iterator5);;) {
						var _ref5;

						if (_isArray5) {
							if (_i5 >= _iterator5.length) break;
							_ref5 = _iterator5[_i5++];
						} else {
							_i5 = _iterator5.next();
							if (_i5.done) break;
							_ref5 = _i5.value;
						}

						var clusion = _ref5;

						if (typeof clusion !== 'string' && !(clusion instanceof RegExp) && typeof clusion !== 'function') {
							throw new Error('Unsupported object type for exclusion/inclusion "' + clusion + '" for asset type "' + asset_type + '"');
						}
					}
					break;

				case 'filter':
				case 'parser':
				case 'path':
					if (typeof description[key] !== 'function') {
						throw new Error('"' + key + '" must be a function for asset type "' + asset_type + '"');
					}
					break;

				default:
					throw new Error('Unknown property "' + key + '" for asset type "' + asset_type + '"');
			}
		}
	}
}

// alias the path if an alias is found,
// and resolve it to a global filesystem path

function alias_hook(path, module, project_path, aliases, log) {
	// possibly alias the path
	var aliased_path = alias(path, aliases);

	// return if an alias not found
	if (!aliased_path) {
		return;
	}

	// if an alias is found, require() the correct path
	log.debug('require("' + path + '") was called and an alias was found, so aliasing to module path "' + aliased_path + '"');

	// resolve the path to a real filesystem path (resolves `npm link`, etc)
	var global_path = _requireHacker2['default'].resolve(aliased_path, module);
	log.debug(' resolved the path for the aliased module to ' + global_path);

	return global_path

	// const result = require(global_path)
	// // log.debug(` the path was found`)

	// return require_hacker.to_javascript_module_source(result)
	;
}

// alias the path provided the aliases map
function alias(path, aliases) {
	// if it's a path to a file - don't interfere
	if (_helpers.starts_with(path, '.') || _helpers.starts_with(path, '/')) {
		return;
	}

	// extract module name from the path
	var slash_index = path.indexOf('/');
	var module_name = slash_index >= 0 ? path.substring(0, slash_index) : path;
	var rest = slash_index >= 0 ? path.substring(slash_index) : '';

	// find an alias
	var alias = aliases[module_name];

	// if an alias is found, require() the correct path
	if (alias) {
		return alias + rest;
	}
}

// converts global asset path to local-to-the-project asset path

function normalize_asset_path(global_asset_path, project_path) {
	// // if this path is outside project folder,
	// // return it as a global path
	// if (!starts_with(global_asset_path, project_path + path.sep))
	// {
	// 	return global_asset_path
	// }

	// this path is inside project folder,
	// convert it to a relative path

	// asset path relative to the project folder
	var asset_path = _path2['default'].relative(project_path, global_asset_path);

	// for Windows:
	//
	// convert Node.js path to a correct Webpack path
	asset_path = uniform_path(asset_path);

	return asset_path;
}

// replaces inner node_modules with ~

function webpack_path(asset_path) {
	// webpack has a shortcut from "node_modules"
	if (_helpers.starts_with(asset_path, './node_modules/')) {
		asset_path = asset_path.replace('./node_modules/', './~/');
	}

	return asset_path;
}

// for Windows:
//
// converts Node.js path to a correct Webpack path

function uniform_path(asset_path) {
	// correct slashes
	asset_path = asset_path.replace(/\\/g, '/');

	// add './' in the beginning if it's missing (for example, in case of Windows)
	if (asset_path.indexOf('.') !== 0) {
		asset_path = './' + asset_path;
	}

	return asset_path;
}
//# sourceMappingURL=common.js.map