{
  "_args": [
    [
      "squel@https://registry.npmjs.org/squel/-/squel-4.2.3.tgz",
      "C:\\app\\isomorphic-material-relay-starter-kit"
    ]
  ],
  "_from": "squel@>=4.2.2 <5.0.0",
  "_id": "squel@4.2.3",
  "_inCache": true,
  "_location": "/squel",
  "_phantomChildren": {},
  "_requested": {
    "name": "squel",
    "raw": "squel@https://registry.npmjs.org/squel/-/squel-4.2.3.tgz",
    "rawSpec": "https://registry.npmjs.org/squel/-/squel-4.2.3.tgz",
    "scope": null,
    "spec": "https://registry.npmjs.org/squel/-/squel-4.2.3.tgz",
    "type": "remote"
  },
  "_requiredBy": [
    "#DEV:/"
  ],
  "_resolved": "https://registry.npmjs.org/squel/-/squel-4.2.3.tgz",
  "_shasum": "0cad22ac8f4c30ea36b86d5e10ea7c04887ef324",
  "_shrinkwrap": null,
  "_spec": "squel@https://registry.npmjs.org/squel/-/squel-4.2.3.tgz",
  "_where": "C:\\app\\isomorphic-material-relay-starter-kit",
  "author": {
    "email": "ram@hiddentao.com",
    "name": "Ramesh Nair",
    "url": "http://www.hiddentao.com/"
  },
  "bugs": {
    "url": "https://github.com/hiddentao/squel/issues"
  },
  "contributors": [
    {
      "email": "ram@hiddentao.com",
      "name": "Ramesh Nair",
      "url": "http://www.hiddentao.com/"
    }
  ],
  "dependencies": {},
  "description": "SQL query string builder",
  "devDependencies": {
    "chai": "1.5.x",
    "coffee-script": "~1.6.3",
    "grunt": "~0.4.1",
    "grunt-contrib-clean": "~0.5.0",
    "grunt-contrib-coffee": "~0.7.0",
    "grunt-contrib-uglify": "~0.2.4",
    "grunt-mocha-test": "~0.6.3",
    "grunt-shell": "~0.4.0",
    "grunt-text-replace": "~0.3.11",
    "load-grunt-tasks": "~0.1.0",
    "mocha": "1.9.x",
    "sinon": "1.6.x",
    "time-grunt": "~0.1.1",
    "uglify-js": "1.3.x",
    "underscore": "1.4.x"
  },
  "engines": {
    "node": ">= 0.6.0"
  },
  "homepage": "https://github.com/hiddentao/squel#readme",
  "keywords": [
    "sql",
    "database",
    "rdbms"
  ],
  "main": "squel",
  "name": "squel",
  "optionalDependencies": {},
  "readme": "# squel - SQL query string builder\n\n[![Build Status](https://secure.travis-ci.org/hiddentao/squel.png?branch=master)](http://travis-ci.org/hiddentao/squel) [![NPM module](https://badge.fury.io/js/squel.png)](https://badge.fury.io/js/squel) [![Join the chat at https://gitter.im/hiddentao/squel](https://img.shields.io/badge/gitter-join%20chat-blue.svg)](https://gitter.im/hiddentao/squel)\n\nA flexible and powerful SQL query string builder for Javascript.\n\nFull documentation (guide and API) at [http://squeljs.org/](http://squeljs.org/).\n\n## Features\n\n* Works in node.js and in the browser.\n* Supports the standard SQL queries: SELECT, UPDATE, INSERT and DELETE.\n* Supports non-standard commands for popular DB engines such as MySQL.\n* Can be customized to build any query or command of your choosing.\n* Uses method chaining for ease of use.\n* Small: ~5 KB minified and gzipped\n* And much more, [see the guide..](http://squeljs.org/)\n\n## Installation\n\n### node.js\n\nInstall using [npm](http://npmjs.org/):\n\n    $ npm install squel\n\n### Browser\n\nUse [bower](https://github.com/bower/bower) if you like:\n\n    $ bower install squel\n\n**WARNING: Do not ever pass queries generated on the client side to your web server for execution.** Such a configuration would make it trivial for a casual attacker to execute arbitrary queries&mdash;as with an SQL-injection vector, but much easier to exploit and practically impossible to protect against.\n\n## Available files\n\n* `squel.js` - unminified version of Squel with the standard commands and all available non-standard commands added\n* `squel.min.js` - minified version of `squel.js`\n* `squel-basic.js` - unminified version of Squel with only the standard SQL commands\n* `squel-basic.min.js` - minified version of `squel-basic.js`\n\n\n## Examples\n\nBefore running the examples ensure you have `squel` installed and enabled at the top of your script:\n\n    var squel = require(\"squel\");\n\n### SELECT\n\n```javascript\n// SELECT * FROM table\nsquel.select()\n    .from(\"table\")\n    .toString()\n\n// SELECT `t1`.`id`, `t1`.`name` as \"My name\", `t1`.`started` as \"Date\" FROM table `t1` ORDER BY id ASC LIMIT 20\nsquel.select({ autoQuoteFieldNames: true })\n    .from(\"table\", \"t1\")\n    .field(\"t1.id\")\n    .field(\"t1.name\", \"My name\")\n    .field(\"t1.started\", \"Date\")\n    .order(\"id\")\n    .limit(20)\n    .toString()\n\n// SELECT t1.id, t2.name FROM table `t1` LEFT JOIN table2 `t2` ON (t1.id = t2.id) WHERE (t2.name <> 'Mark') AND (t2.name <> 'John') GROUP BY t1.id\nsquel.select()\n    .from(\"table\", \"t1\")\n    .field(\"t1.id\")\n    .field(\"t2.name\")\n    .left_join(\"table2\", \"t2\", \"t1.id = t2.id\")\n    .group(\"t1.id\")\n    .where(\"t2.name <> 'Mark'\")\n    .where(\"t2.name <> 'John'\")\n    .toString()\n```\n\nYou can use nested queries too:\n\n```javascript\n// SELECT s.id FROM (SELECT * FROM students) `s` INNER JOIN (SELECT id FROM marks) `m` ON (m.id = s.id)\nsquel.select()\n    .from( squel.select().from('students'), 's' )\n    .field('id')\n    .join( squel.select().from('marks').field('id'), 'm', 'm.id = s.id' )\n    .toString()\n```\n\n### UPDATE\n\n```javascript\n// UPDATE test SET f1 = 1\nsquel.update()\n    .table(\"test\")\n    .set(\"f1\", 1)\n    .toString()\n\n// UPDATE test, test2, test3 AS `a` SET test.id = 1, test2.val = 1.2, a.name = \"Ram\", a.email = NULL, a.count = a.count + 1\nsquel.update()\n    .table(\"test\")\n    .set(\"test.id\", 1)\n    .table(\"test2\")\n    .set(\"test2.val\", 1.2)\n    .table(\"test3\",\"a\")\n    .setFields({\n        \"a.name\": \"Ram\",\n        \"a.email\": null,\n        \"a.count = a.count + 1\": undefined\n    })\n    .toString()\n```\n\n### INSERT\n\n```javascript\n// INSERT INTO test (f1) VALUES (1)\nsquel.insert()\n    .into(\"test\")\n    .set(\"f1\", 1)\n    .toString()\n\n// INSERT INTO test (name, age) VALUES ('Thomas', 29), ('Jane', 31)\nsquel.insert()\n    .into(\"test\")\n    .setFieldsRows([\n        { name: \"Thomas\", age: 29 },\n        { name: \"Jane\", age: 31 }    \n    ])\n    .toString()\n```\n\n### DELETE\n\n```javascript\n// DELETE FROM test\nsquel.delete()\n    .from(\"test\")\n    .toString()\n\n// DELETE FROM table1 WHERE (table1.id = 2) ORDER BY id DESC LIMIT 2\nsquel.delete()\n    .from(\"table1\")\n    .where(\"table1.id = ?\", 2)\n    .order(\"id\", false)\n    .limit(2)\n```\n\n### Paramterized queries\n\nUse the `useParam()` method to obtain a parameterized query with a separate list of formatted parameter values:\n\n```javascript\n// { text: \"INSERT INTO test (f1, f2, f3, f4, f5) VALUES (?, ?, ?, ?, ?)\", values: [1, 1.2, \"TRUE\", \"blah\", \"NULL\"] }\nsquel.insert()\n    .into(\"test\")\n    .set(\"f1\", 1)\n    .set(\"f2\", 1.2)\n    .set(\"f3\", true)\n    .set(\"f4\", \"blah\")\n    .set(\"f5\", null)\n    .toParam()\n```\n\n\n### Expression builder\n\nThere is also an expression builder which allows you to build complex expressions for `WHERE` and `ON` clauses:\n\n```javascript\n// test = 3 OR test = 4\nsquel.expr()\n    .or(\"test = 3\")\n    .or(\"test = 4\")\n    .toString()\n\n// test = 3 AND (inner = 1 OR inner = 2) OR (inner = 3 AND inner = 4 OR (inner IN ('str1, 'str2', NULL)))\nsquel.expr()\n    .and(\"test = 3\")\n    .and_begin()\n        .or(\"inner = 1\")\n        .or(\"inner = 2\")\n    .end()\n    .or_begin()\n        .and(\"inner = ?\", 3)\n        .and(\"inner = ?\", 4)\n        .or_begin()\n            .and(\"inner IN ?\", ['str1', 'str2', null])\n        .end()\n    .end()\n    .toString()\n\n// SELECT * FROM test INNER JOIN test2 ON (test.id = test2.id) WHERE (test = 3 OR test = 4)\nsquel.select()\n    .join( \"test2\", null, squel.expr().and(\"test.id = test2.id\") )\n    .where( squel.expr().or(\"test = 3\").or(\"test = 4\") )\n```\n\n### Custom value types\n\nBy default Squel does not support the use of object instances as field values. Instead it lets you tell it how you want\nspecific object types to be handled:\n\n```javascript\n// handler for objects of type Date\nsquel.registerValueHandler(Date, function(date) {\n  return date.getFullYear() + '/' + (date.getMonth() + 1) + '/' + date.getDate();\n});\n\nsquel.update().\n  .table('students')\n  .set('start_date', new Date(2013, 5, 1))\n  .toString()\n\n// UPDATE students SET start_date = '2013/6/1'\n```\n\n\n_Note that custom value handlers can be overridden on a per-instance basis (see the [docs](http://squeljs.org/))_\n\n### Custom queries\n\nSquel allows you to override the built-in query builders with your own as well as create your own types of queries:\n\n```javascript\n// ------------------------------------------------------\n// Setup the PRAGMA query builder\n// ------------------------------------------------------\nvar util = require('util');   // to use util.inherits() from node.js\n\nvar CommandBlock = function() {};\nutil.inherits(CommandBlock, squel.cls.Block);\n\n// private method - will not get exposed within the query builder\nCommandBlock.prototype._command = function(_command) {\n  this._command = _command;\n}\n\n// public method - will get exposed within the query builder\nCommandBlock.prototype.compress = function() {\n  this._command('compress');\n};\n\nCommandBlock.prototype.buildStr = function() {\n  return this._command.toUpperCase();\n};\n\n\n// generic parameter block\nvar ParamBlock = function() {};\nutil.inherits(ParamBlock, squel.cls.Block);\n\nParamBlock.prototype.param = function(p) {\n  this._p = p;\n};\n\nParamBlock.prototype.buildStr = function() {\n  return this._p;\n};\n\n\n// pragma query builder\nvar PragmaQuery = function(options) {\n  squel.cls.QueryBuilder.call(this, options, [\n      new squel.cls.StringBlock(options, 'PRAGMA'),\n      new CommandBlock(),\n      new ParamBlock()\n  ]);\n};\nutil.inherits(PragmaQuery, squel.cls.QueryBuilder);\n\n\n// convenience method (we can override built-in squel methods this way too)\nsquel.pragma = function(options) {\n  return new PragmaQuery(options)\n};\n\n\n// ------------------------------------------------------\n// Build a PRAGMA query\n// ------------------------------------------------------\n\nsquel.pragma()\n  .compress()\n  .param('test')\n  .toString();\n\n// 'PRAGMA COMPRESS test'\n```\n\nExamples of custom queries in the wild:\n\n * https://github.com/bostrt/squel-top-start-at (blog post about it: http://blog.bostrt.net/extending-squel-js/)\n\n\n## Non-standard SQL\n\nSquel supports the standard SQL commands and reserved words. However a number of database engines provide their own\nnon-standard commands. To make things easy Squel allows for different 'flavours' of SQL to be loaded and used.\n\nAt the moment Squel provides `mysql`, `mssql` and `postgres` flavours which augment query builders with additional commands (e.g. `INSERT ... RETURNING`\nfor use with Postgres).\n\nTo use this in node.js:\n\n```javascript\nvar squel = require('squel').useFlavour('postgres');\n```\n\nFor the browser:\n\n```html\n<script type=\"text/javascript\" src=\"https://rawgithub.com/hiddentao/squel/master/squel.min.js\"></script>\n<script type=\"text/javascript\">\n  squel = squel.useFlavour('postgres');\n</script>\n```\n\n(Internally the flavour setup method simply utilizes the [custom query mechanism](http://hiddentao.github.io/squel/#custom_queries) to effect changes).\n\nRead the the [API docs](http://hiddentao.github.io/squel/api.html) to find out available commands. Flavours of SQL which get added to\nSquel in the future will be usable in the above manner.\n\n## Building it\n\nTo build the code and run the tests:\n\n    $ npm install -g grunt-cli\n    $ npm install\n    $ grunt <-- this will build the code and run the tests\n\n\n## Contributing\n\nContributions are welcome! Please see CONTRIBUTING.md.\n\n\n## Ports to other languages\n\n* .NET - https://github.com/seymourpoler/PetProjects/tree/master/SQUEL\n\n## License\n\nMIT - see LICENSE.md",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/hiddentao/squel.git"
  },
  "scripts": {
    "build": "grunt",
    "prepublish": "npm build",
    "test": "grunt"
  },
  "version": "4.2.3"
}
